---
title: "s09 Exercises: Factors"
output: 
  html_document:
    keep_md: true
    theme: paper
---

```{r allow errors, echo = FALSE}
knitr::opts_chunk$set(error = TRUE)
```

```{r load packages, message = FALSE}
library(gapminder)
library(tidyverse) # includes, among others, `forcats`
```


## Motivating the need for factors in R

### Activity 1: Using factors for plotting 

**1.1** Let's look again into `gapminder` dataset and create a new cloumn, 
`life_level`, that contains five categories ("very high", "high","moderate", 
"low", "very low") based on life expectancy in 1997. Assign categories accoring 
to the table below:

| Criteria | life_level | 
|-------------|-----------|
| less than 23 | very low |
| between 23 and 48 | low |
| between 48 and 59 | moderate |
| between 59 and 70 | high |
| more than 70 | very high |

Function `case_when()` is a tidier way to vectorise multiple `if_else()` statements. 
You can read more about this function [here](https://dplyr.tidyverse.org/reference/case_when.html).

Note: You don't have to use the same variable for all rules in case_when chunk

```{r}
gapminder %>% 
  filter(year == 1997) %>% 
  mutate(life_level = case_when(lifeExp < 23 ~ "very low",
                                lifeExp < 48 ~ "low",
                                lifeExp < 59 ~ "moderate",
                                lifeExp < 70 ~ "high",
                                # else
                                TRUE ~ "very high")) %>% 
  ggplot() + 
  geom_boxplot(aes(x = life_level, y = gdpPercap)) +
  labs(y = "GDP per capita, $", x = "Life expectancy level, years") +
  theme_bw() 
```

Do you notice anything odd/wrong about the graph?

We can make a few observations:

- It seems that none of the countries had a "very low" life-expectancy in 1997. 

- However, since it was an option in our analysis it should be included in our plot. Right?

- Notice also how levels on x-axis are placed in the "wrong" order. It's arranged alphabetically.

**1.2** You can correct these issues by explicitly setting the levels parameter 
in the call to `factor()`. Use, `drop = FALSE` to tell the plot not to drop 
unused levels.

Main differences: use "factor()" in addition to "case when" and add "levels", concatonating levels in proper order. Last line instructs to not drop any factors.

```{r}
gapminder %>% 
  filter(year == 1997) %>% 
  mutate(life_level = factor(
    case_when(lifeExp < 23 ~ "very low",
              lifeExp < 48 ~ "low",
              lifeExp < 59 ~ "moderate",
              lifeExp < 70 ~ "high",
              # else
              TRUE ~ "very high") ,
                      levels = c("very low", "low", "moderate", "high", "very high"))) %>% 
  ggplot() + 
  geom_boxplot(aes(x = life_level, y = gdpPercap)) +
  labs(y = "GDP per capita, $", x = "Life expectancy level, years") +
  theme_bw() +
  scale_x_discrete(drop = FALSE) # don't drop any factors
```

## Activity 2: Inspecting factors

In Activity 1, we created our own factors, so now let's explore what 
categorical variables that we have in the `gapminder` dataset.

### **2.1** Exploring `gapminder$continent`

Use functions such as `str()`, `levels()`, `nlevels()` and `class()` to 
answer the following questions:

- What class (type of object) is `continent` (a factor or character)?
- How many levels? What are they?
- What integer is used to represent factor "Asia"?

```{r}
class(gapminder$continent) # check what type of object (factor or character)

str(gapminder$continent)
nlevels(gapminder$continent)  # how many levels
levels(gapminder$continent)  # what are the levels

# another way to determine what level represents Asia
filter(gapminder, continent == "Asia") %>% 
  pull(continent) %>% 
       as.numeric()
```

Continent is classified as a factor.
It has 5 levels (Africa, Americas, Asia, Europe, Oceania)


### **2.2** Exploring `gapminder$country`

Let's explore what else we can do with factors. Answer the following questions: 

- How many levels are there in `country`?
- Filter `gapminder` dataset by 5 countries of your choice. How many levels are 
  in your filtered dataset?

```{r}
nlevels(gapminder$country)
levels(gapminder$country)

gapminder %>% 
  filter(country == c("Iran", "Israel", "Jordan", "Oman", "Pakistan")) %>% 
  pull(country) %>% 
  as.numeric()

# another way
h_countries <- c("Egypt", "Haiti", "Romania", "Thailand", "Venezuela")

h_gap <- gapminder %>%
  filter(country %in% h_countries)

nlevels(h_gap$country)

# can do this using dplyr too
h_gap$country %>% 
  nlevels()
```

Country has 142 levels. After filtering to only 5 countries, we still have 142 levels (they just don't have any values).
Filtered to Iran, Israel, Jordan, Oman, and Pakistan. The corresponding numeric levels are 61, 64, 68, 97, and 98, respectively.


## Dropping unused levels

What if we want to get rid of some levels that are "unused" -- how do we do that? 

The function `droplevels()` operates on all the factors in a data frame or on a 
single factor. The function `forcats::fct_drop()` operates on a factor and does 
not drop `NA` values.

```{r}
h_gap_dropped <- h_gap %>% 
  droplevels()

h_gap_dropped$country %>%
  nlevels()
```

## Changing the order of levels

Let's say we wanted to re-order the levels of a factor using a new metric - say, count().

We should first produce a frequency table as a tibble using `dplyr::count()`:

```{r}
gapminder %>% 
  count(continent)
```

The table is nice, but it would be better to visualize the data.
Factors are most useful/helpful when plotting data.
So let's first plot this:

```{r}
gapminder %>%
  ggplot() +
  geom_bar(aes(continent)) +
  coord_flip() +
  theme_bw() +
  ylab("Number of entries") + xlab("Continent")
```

Think about how levels are normally ordered. 
It turns out that by default, R always sorts levels in alphabetical order. 
However, it is often preferable to order the levels according to some principle:

  1. Frequency/count (`fct_infreq()`)
  2. Order of appearance (`fct_inorder()`)
  3. Sequence of the underlying integers (`fct_inseq()`)
  
- Make the most common level the first and so on. Function like `fct_infreq()` 
  might be useful.
- The function `fct_rev()` will sort them in the opposite order.

```{r}
gapminder %>%
  ggplot() +
  geom_bar(aes(fct_inorder(continent))) +
  coord_flip() +
  theme_bw() +
  ylab("Number of entries") + xlab("Continent")

# in order of frequency
gapminder %>%
  ggplot() +
  geom_bar(aes(fct_infreq(continent))) +
  coord_flip() +
  theme_bw() +
  ylab("Number of entries") + xlab("Continent")

# reverse order
gapminder %>%
  ggplot() +
  geom_bar(aes(fct_rev(continent))) +
  coord_flip() +
  theme_bw() +
  ylab("Number of entries") + xlab("Continent")
```

Section 9.6 of Jenny Bryan's [notes](https://stat545.com/factors-boss.html#reorder-factors) has some helpful examples.

  4. Another variable. 
  
  - For example, if we wanted to bring back our example of ordering `gapminder` 
    countries by life expectancy, we can visualize the results using `fct_reorder()`. 

```{r}
##  default summarizing function is median()
gapminder %>%
  ggplot() +
  geom_bar(aes(fct_reorder(continent, lifeExp, max))) +
  coord_flip() +
  theme_bw() +
  xlab("Continent") + ylab("Number of entries")
```

Use `fct_reorder2()` when you have a line chart of a quantitative x against 
another quantitative y and your factor provides the color. 

```{r}
## order by life expectancy 
ggplot(h_gap, aes(x = year, y = lifeExp,
                  color = fct_reorder2(country, year, lifeExp))) +
  geom_line() +
  labs(color = "Country")
```

## Change order of the levels manually

This might be useful if you are preparing a report for say, the state of affairs 
in Africa.

```{r}
gapminder %>%
  ggplot() +
  geom_bar(aes(fct_relevel(continent, "Oceania", "Europe"))) + # Oceania will be last, Europe second-to-last
  coord_flip()+
  theme_bw()
```

More details on reordering factor levels by hand can be found 
[here](https://forcats.tidyverse.org/reference/fct_relevel.html).

## Recoding factors

Sometimes you want to specify what the levels of a factor should be.
For instance, if you had levels called "blk" and "brwn", you would rather they 
be called "Black" and "Brown" -- this is called recoding.

Lets recode `Oceania` and the `Americas` in the graph above as abbreviations 
`OCN` and `AME` respectively using the function `fct_recode()`.

```{r}
gapminder %>%
  ggplot() +
  geom_bar(aes(fct_recode(continent, "OCN" = "Oceania", "AME" = "Americas"))) +
  coord_flip() +
  theme_bw()
```

## Grow a factor (OPTIONAL)

Letâ€™s create two data frames,`df1` and `df2` each with data from two countries, 
dropping unused factor levels.

```{r}
df1 <- gapminder %>% 
  filter(country %in% c("United States", "Mexico"), year > 2000) %>% 
  droplevels()

nlevels(df1$country)

df2 <- gapminder %>% 
  filter(country %in% c("France", "Germany"), year > 2000) %>% 
  droplevels()

nlevels(df2$country)
```

The country factors in `df1` and `df2` have different levels.
Can you just combine them using `c()`?

```{r}
c(df1$country, df2$country)
```
This isn't what we want. Remember that factors are a number of vectors. These factors had two different lookup tables. In df1, 1 meant United States, whereas in df2, 1 meant France.

Use `fct_c()` to perform `c()`, but also combine the levels of the two factor
variables:

```{r}
fct_c(df1$country, df2$country)
```
This gives us what we want because it treats them like factors rather than numbers.

Explore how different forms of row binding work behave here, in terms of the 
country variable in the result. 

```{r}
bind_rows(df1, df2)
```

Warning says: Uneven factor levels; we'll just use labels instead bc they're more important.

```{r}
rbind(df1, df2)
```

